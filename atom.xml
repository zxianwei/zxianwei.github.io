<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zxianwei.github.io</id>
    <title>zxianwei</title>
    <updated>2020-08-19T15:38:10.009Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zxianwei.github.io"/>
    <link rel="self" href="https://zxianwei.github.io/atom.xml"/>
    <subtitle>念念不忘，必有回响。</subtitle>
    <logo>https://zxianwei.github.io/images/avatar.png</logo>
    <icon>https://zxianwei.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, zxianwei</rights>
    <entry>
        <title type="html"><![CDATA[Mac彻底卸载搜狗输入法，看这一篇就够了]]></title>
        <id>https://zxianwei.github.io/mac-che-di-xie-zai-sou-gou-shu-ru-fa-kan-zhe-yi-pian-jiu-gou-liao/</id>
        <link href="https://zxianwei.github.io/mac-che-di-xie-zai-sou-gou-shu-ru-fa-kan-zhe-yi-pian-jiu-gou-liao/">
        </link>
        <updated>2020-04-29T07:47:35.000Z</updated>
        <summary type="html"><![CDATA[<p>       今天手把手教大家如何卸载搜狗输入法，希望能帮到您！</p>
]]></summary>
        <content type="html"><![CDATA[<p>       今天手把手教大家如何卸载搜狗输入法，希望能帮到您！</p>
<!-- more -->
<p>       对于初次使用Mac电脑的同学，想卸载搜狗输入法发现在应用程序中是找不到的，因为他没有安装到<strong>应用程序</strong>中，也就无法像常规那样卸载的。如果去百度可能会找到这样的解决办法：</p>
<pre><code class="language-java"># rm -rf /Library/Input\ Methods/SogouInput.app
# rm -rf /Users/自己用户名/Library/Caches/SogouServices
# rm -rf /Users/自己用户名/.sogouinput
</code></pre>
<p>如果这样操作可能会遇到我这样到错误：<br>
<img src="https://s1.ax1x.com/2020/04/29/JT7q5n.png" alt="示意图" loading="lazy"><br>
大多少同学可能无法解决。好啦吧啦吧啦说了一堆，接下来是正题的时候了：电脑中如果有搜狗输入法安装包，没有的再去官网下载一下；下载下来的文件解压打开：<br>
<img src="https://s1.ax1x.com/2020/04/29/JTb1w4.png" alt="示意图" loading="lazy"><br>
剩下的步骤就是输入密码确认卸载，最后记得注销哦！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何在Spring Boot开启事务]]></title>
        <id>https://zxianwei.github.io/ru-he-zai-spring-boot-kai-qi-shi-wu/</id>
        <link href="https://zxianwei.github.io/ru-he-zai-spring-boot-kai-qi-shi-wu/">
        </link>
        <updated>2020-04-14T05:45:12.000Z</updated>
        <summary type="html"><![CDATA[<p>今天给大家介绍如何在Spring Boot中开启事务，希望大家喜欢。<br>
<strong>说到事务，那什么是事务呢？</strong></p>
]]></summary>
        <content type="html"><![CDATA[<p>今天给大家介绍如何在Spring Boot中开启事务，希望大家喜欢。<br>
<strong>说到事务，那什么是事务呢？</strong></p>
<!-- more -->
<blockquote>
<p>事务（Transaction），一般是指要做的或所做的事情。</p>
<ul>
<li><strong>原子性（Atomicity）</strong>：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li>
<li><strong>一致性（Consistency）</strong>：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。</li>
<li><strong>隔离性（Isolation）</strong>：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li>
<li><strong>持久性（Durability）</strong>：已被提交的事务对数据库的修改应该永久保存在数据库中。</li>
</ul>
</blockquote>
<p>那么如何在Spring Boot中使用呢？其实只需要两步即可：</p>
<ol>
<li>在Application上添加@EnableTransactionManagement注解，用来开启事务。</li>
<li>在Service实现类的方法上添加@Transactional注解。</li>
</ol>
<p><strong>具体实现：</strong><br>
使用<a href="https://blog.csdn.net/m0_46696320/article/details/105472191">《Spring Boot中使用MyBatis详解》</a>的代码，在TransactionalApplication启动类上添加@EnableTransactionManagement注解开启事务：</p>
<pre><code class="language-java">package com.zxw.transactional;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@SpringBootApplication
//开启事务
@EnableTransactionManagement
public class TransactionalApplication {

    public static void main(String[] args) {
        SpringApplication.run(TransactionalApplication.class, args);
    }

}
</code></pre>
<p>在Service实现方法上添加@Transactional注解：</p>
<pre><code class="language-java">package com.zxw.transactional.controller;

import com.zxw.transactional.bean.PoetryBean;
import com.zxw.transactional.service.PoetryService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.PostMapping;

@Controller
public class PoetryController {

    @Autowired
    private PoetryService poetryService;

    @Transactional
    @PostMapping(&quot;/register&quot;)
    public String registerVerse(PoetryBean poetryBean) {
        poetryService.addVerse(poetryBean);
        int i = 3 / 0;
        poetryService.addVerse(poetryBean);
        return &quot;success&quot;;
    }
}
</code></pre>
<p>我在registerVerse方法添加了int i = 3 / 0;的代码，这段代码肯定会报错，在加了@Transactional注解后，我们看下可以往数据库插入几条数据？如果把@Transactional注解去掉又能添加几条呢？大家可以试试。</p>
<blockquote>
<p>项目地址：<a href="https://github.com/zxianwei/HelloSpringBoot">HelloSpringBoot</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Boot中使用MyBatis详解]]></title>
        <id>https://zxianwei.github.io/spring-boot-zhong-shi-yong-mybatis-xiang-jie/</id>
        <link href="https://zxianwei.github.io/spring-boot-zhong-shi-yong-mybatis-xiang-jie/">
        </link>
        <updated>2020-04-12T15:38:39.000Z</updated>
        <summary type="html"><![CDATA[<p>今天给大家介绍如何在Spring Boot中使用MyBatis，希望大家喜欢。</p>
<h4 id="1-创建项目">1. 创建项目</h4>
<p>关于如何创建Spring Boot的项目，大家可以参考我的<a href="https://zxianwei.github.io/hellospring/">《Hello Spring Boot》</a>里面有详细介绍。</p>
]]></summary>
        <content type="html"><![CDATA[<p>今天给大家介绍如何在Spring Boot中使用MyBatis，希望大家喜欢。</p>
<h4 id="1-创建项目">1. 创建项目</h4>
<p>关于如何创建Spring Boot的项目，大家可以参考我的<a href="https://zxianwei.github.io/hellospring/">《Hello Spring Boot》</a>里面有详细介绍。</p>
<!-- more -->
<h4 id="2-导入依赖">2. 导入依赖</h4>
<p>在Spring Boot中使用MyBatis主要用到了三个依赖：MyBatis和Spring Boot 整合依赖、MySQL驱动依赖、Druid依赖。基于本文还需要另外两个依赖：jsp解析器、lombok。下面展示一下我的pom文件:</p>
<pre><code class="language-xml"> &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
            &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--MyBatis和Spring Bot整合框架--&gt;
        &lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.1.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--mysql驱动依赖--&gt;
        &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- Druid依赖--&gt;
        &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid&lt;/artifactId&gt;
            &lt;version&gt;1.1.22&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;


        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;

        &lt;resources&gt;
            &lt;!--注册webapp资源目录--&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/webapp&lt;/directory&gt;
                &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/*.*&lt;/include&gt;
                &lt;/includes&gt;
            &lt;/resource&gt;
            &lt;!--注册dao包下mybatis映射文件为资源目录--&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/java&lt;/directory&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/*.xml&lt;/include&gt;
                &lt;/includes&gt;
            &lt;/resource&gt;
        &lt;/resources&gt;
    &lt;/build&gt;
</code></pre>
<p><strong>org.mybatis.spring.boot 这个依赖的版本号是不能省去</strong>，因为这个依赖是MyBatis整合的Spring Boot，而不是Spring Boot整合的它，所以不能省掉。<br>
<strong>resources</strong>中的两个配置分别是注册webapp为资源目录、注册MyBatis的资源目录。<br>
看到这么多依赖肯定有小伙伴问，我是从哪里知道的，大家可以访问这个<a href="https://mvnrepository.com/">网址</a>查找。</p>
<h4 id="3-创建jsp">3. 创建Jsp</h4>
<p>如何在Spring Boot中使用Jsp大家可以参考<a href="https://zxianwei.github.io/spring-boot-shi-yong-jsp/">《Spring Boot 使用jsp》</a>，创建两个jsp文件分别是：index.jsp、success.jsp他们用来提交表单和展示结果。</p>
<pre><code class="language-javascript">&lt;%--
  Created by IntelliJ IDEA.
  User: zhangxianwei
  Date: 2020/4/12
  Time: 12:55 下午
  To change this template use File | Settings | File Templates.
--%&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action=&quot;register&quot; method=&quot;post&quot;&gt;
    诗句：&lt;input type=&quot;text&quot; name=&quot;verse&quot; style=&quot;width: 200px&quot;&gt;
    &lt;br&gt;
    &lt;br&gt;
    作者：&lt;input type=&quot;text&quot; name=&quot;author&quot; style=&quot;width: 200px&quot;&gt;
    &lt;br&gt;
    &lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="language-javascript">&lt;%--
  Created by IntelliJ IDEA.
  User: zhangxianwei
  Date: 2020/4/12
  Time: 1:26 下午
  To change this template use File | Settings | File Templates.
--%&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h5&gt;提交成功&lt;/h5&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="4创建数据库">4.创建数据库</h4>
<p>使用Navicat创建了一个poetry的表：<img src="https://img-blog.csdnimg.cn/20200412215820686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2Njk2MzIw,size_16,color_FFFFFF,t_70" alt="示意图" loading="lazy"></p>
<h4 id="5创建实体类">5.创建实体类</h4>
<p>在项目的包名下创建一个目录名为：bean,再创建一个PoetryBean的类：</p>
<pre><code class="language-java">package com.zxw.mybatis.bean;

import lombok.Data;

@Data
public class PoetryBean {
    private Integer id;
    private String verse;
    private String author;
}
</code></pre>
<h4 id="6创建dao层">6.创建dao层</h4>
<p>在项目的包名下创建一个目录名为：dao，再创建一个接口PoetryDao，不要忘记加上@Mapper注解。</p>
<pre><code class="language-java">package com.zxw.mybatis.dao;

import com.zxw.mybatis.bean.PoetryBean;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface PoetryDao {

    void insertVerse(PoetryBean poetryBean);
}
</code></pre>
<p>然后在resources目录下创建与其对应的配置文件：PoetryDao.xml</p>
<pre><code class="language-javascript">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.zxw.mybatis.dao.PoetryDao&quot;&gt;
    &lt;insert id=&quot;insertVerse&quot;&gt;
     INSERT INTO poetry(verse,author ) VALUES (#{verse},#{author})
     &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
<p>首先这里面的id要和上面的方法一一对应，然后再写SQL语句就好了，这里推荐一个MybatisX的插件(类似于eventbus3-intellij-plugin这个插件)，装上这个插件就可以直接定位到xml防止写错，而且这个插件很强大，感兴趣的去它的<a href="https://mybatis.plus/">官网</a>。</p>
<h4 id="7创建service">7.创建service</h4>
<p>在项目的包名下创建一个目录名为：service，再创建接口PoetryService：</p>
<pre><code class="language-java">package com.zxw.mybatis.service;

import com.zxw.mybatis.bean.PoetryBean;

public interface PoetryService {

    void addVerse(PoetryBean poetryBean);
}
</code></pre>
<p>创建实现类PoetryServiceImpl：</p>
<pre><code class="language-java">package com.zxw.mybatis.service;

import com.zxw.mybatis.bean.PoetryBean;
import com.zxw.mybatis.dao.PoetryDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class PoetryServiceImpl implements PoetryService {

    @Autowired
    PoetryDao poetryDao;

    @Override
    public void addVerse(PoetryBean poetryBean) {
        poetryDao.insertVerse(poetryBean);
    }
}
</code></pre>
<p>这个类中不要忘记加上@Service这个注解，我当时就是忘记加而报错了。</p>
<h4 id="8创建controller">8.创建Controller</h4>
<p>在项目的包名下载创建一个目录名为：controller，再创建类PoetryController：</p>
<pre><code class="language-java">package com.zxw.mybatis.controller;

import com.zxw.mybatis.bean.PoetryBean;
import com.zxw.mybatis.service.PoetryService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;

@Controller
public class PoetryController {

    @Autowired
    private PoetryService poetryService;

    @PostMapping(&quot;/register&quot;)
    private String registerVerse(PoetryBean poetryBean) {
        poetryService.addVerse(poetryBean);
        return &quot;success&quot;;
    }
}

</code></pre>
<p>这个段代码就是当诗词提交成功后，返回success这个jsp用来通知提交成功。</p>
<h4 id="9配置">9.配置</h4>
<p>在application.properties文件中做一下配置：</p>
<pre><code class="language-javascript"># 视图的前辍与后辍
spring.mvc.view.prefix=/
spring.mvc.view.suffix=.jsp

# 注册映射文件
mybatis.mapper-locations=classpath:PoetryDao.xml
# 注册实体类别名
mybatis.type-aliases-package=com.zxw.mybatis.bean
# 注册数据源类型
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
# 连接数据库
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql:///db1
spring.datasource.username=root
spring.datasource.password=zxw12345
</code></pre>
<h4 id="10检查">10.检查</h4>
<p>运行项目添加诗句检查结果如图：<br>
<img src="https://img-blog.csdnimg.cn/20200412230814743.gif" alt="在这里插入图片描述" loading="lazy"></p>
<h4 id="总结">总结</h4>
<p>以上就是在Spring Boot中使用MyBatis详细步骤，总结如下：</p>
<ul>
<li>在pom文件找那个添加：MyBatis与Spring Boot整合依赖、MySQL驱动依赖，和Druid依赖。</li>
<li>在配置文件中添加：映射文件、实体类别名，及数据源。</li>
<li>在Dao接口上添加@Mapper注解。</li>
</ul>
<blockquote>
<p>项目地址：<a href="https://github.com/zxianwei/HelloSpringBoot">HelloSpringBoot</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android Studio奇葩问题]]></title>
        <id>https://zxianwei.github.io/android-studio-qi-pa-wen-ti/</id>
        <link href="https://zxianwei.github.io/android-studio-qi-pa-wen-ti/">
        </link>
        <updated>2020-04-11T13:18:20.000Z</updated>
        <summary type="html"><![CDATA[<p>突然之间Android Studio 没有了代码提示，打不出比如Button等控件无法导入相应的包。</p>
]]></summary>
        <content type="html"><![CDATA[<p>突然之间Android Studio 没有了代码提示，打不出比如Button等控件无法导入相应的包。</p>
<!-- more -->
<p>可以采用以下方法：<br>
<img src="https://upload-images.jianshu.io/upload_images/4148711-aba49deb7fd94c42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Boot 使用jsp]]></title>
        <id>https://zxianwei.github.io/spring-boot-shi-yong-jsp/</id>
        <link href="https://zxianwei.github.io/spring-boot-shi-yong-jsp/">
        </link>
        <updated>2020-04-06T16:23:44.000Z</updated>
        <summary type="html"><![CDATA[<p>在Spring Boot中并不推荐使用jsp，如果想要在Spring Boot中使用jsp就需要做专门的配置了。</p>
<h3 id="1-创建webapp目录">1. 创建webapp目录</h3>
]]></summary>
        <content type="html"><![CDATA[<p>在Spring Boot中并不推荐使用jsp，如果想要在Spring Boot中使用jsp就需要做专门的配置了。</p>
<h3 id="1-创建webapp目录">1. 创建webapp目录</h3>
<!-- more -->
<p>在项目/main/目录下创建webapp目录，注意要是和resources、java同级。<br>
<img src="https://s1.ax1x.com/2020/04/06/G6YOVe.jpg" alt="示意图" loading="lazy"><br>
创建好了直接在这个目录下新建jsp是不能创建的，如果硬要创建是没有jsp模板的，问题主要在于这个目录不是web资源目录，idea是不能自动识别的，所以咱们要把这个目录变成web资源目录。打开项目的Project Settings(快捷键：command+;)，找到Web Resource Directories点击加号，再选择webapp目录点击OK，最后点击OK保存就好了。<img src="https://s1.ax1x.com/2020/04/07/G6NRh9.gif" alt="示意图" loading="lazy"></p>
<h3 id="2-创建jsp文件">2. 创建jsp文件</h3>
<p>我创建了一个hello.jsp的文件，代码如下：</p>
<pre><code>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
   hello jsp
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="3-添加物理视图">3. 添加物理视图</h3>
<p>打开pom.xml文件添加tomcat-embed-jasper依赖，这个依赖用于解析jsp文件。</p>
<pre><code>        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
            &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<p>然后在build中注册webapp资源目录</p>
<pre><code>        &lt;resources&gt;
            &lt;!--注册webapp资源目录--&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/webapp&lt;/directory&gt;
                &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/*.*&lt;/include&gt;
                &lt;/includes&gt;
            &lt;/resource&gt;
        &lt;/resources&gt;
</code></pre>
<h3 id="4-查看">4. 查看</h3>
<p>运行项目在浏览器输入：http://localhost:8080/hello.jsp<br>
<img src="https://s1.ax1x.com/2020/04/07/G6Ur8A.png" alt="示意图" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Boot 定义异常页面]]></title>
        <id>https://zxianwei.github.io/spring-boot-ding-yi-yi-chang-ye-mian/</id>
        <link href="https://zxianwei.github.io/spring-boot-ding-yi-yi-chang-ye-mian/">
        </link>
        <updated>2020-04-06T10:17:47.000Z</updated>
        <summary type="html"><![CDATA[<p>       对于异常服务器通常会给出默认的异常页面，而这些默认的异常页面有时候不太友好，这时候我们就需要自定义并且替换默认页面。</p>
]]></summary>
        <content type="html"><![CDATA[<p>       对于异常服务器通常会给出默认的异常页面，而这些默认的异常页面有时候不太友好，这时候我们就需要自定义并且替换默认页面。</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/04/06/GydnUg.png" alt="" loading="lazy"></figure>
<p>1.定义目录<br>
在项目/src/main/resources/ 目录下再定义/public/error/如图<br>
<img src="https://s1.ax1x.com/2020/04/06/Gy0C6I.png" alt="" loading="lazy"><br>
2.定义异常页面<br>
在/public/error/目录下创建异常页面，比如404页面，只需要创建一个404.html的文件就可以替换默认的404页面了。<br>
<img src="https://s1.ax1x.com/2020/04/06/Gy0bCQ.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Boot 热部署]]></title>
        <id>https://zxianwei.github.io/spring-boot-re-bu-shu/</id>
        <link href="https://zxianwei.github.io/spring-boot-re-bu-shu/">
        </link>
        <updated>2020-03-29T13:32:07.000Z</updated>
        <summary type="html"><![CDATA[<p>       在开发调试过程中，已经启动了工程的运行。此时又修改了代码或者配置文件，若要使配置生效，就需要重新启动工程，这种方式降低了开发效率。</p>
]]></summary>
        <content type="html"><![CDATA[<p>       在开发调试过程中，已经启动了工程的运行。此时又修改了代码或者配置文件，若要使配置生效，就需要重新启动工程，这种方式降低了开发效率。</p>
<!-- more -->
<p>       热部署，在修改了代码或者配置一经保存，系统就会对工程自动重启，不需要手动重启。若要实现热部署只需要在配置文件中添加一个依赖即可。</p>
<pre><code> &lt;dependency&gt;
    　&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    　&lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>       找到项目的配置然后如图选择，这样做的就是当idea整个窗口被钝化的时候工程就会自动部署。何为窗口钝化就是当应用切换到其他窗口的时候。<br>
<img src="https://s1.ax1x.com/2020/03/29/GZ6Krd.png" alt="" loading="lazy"></p>
<p>       自动部署有利也有弊，有利的地方就是无需手动重启，弊端就是有些代码还没有修改完毕，切换其他应用的时候也会自动部署，另外自动部署有时会出现一些神奇的bug。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[珍藏的句子]]></title>
        <id>https://zxianwei.github.io/zhen-cang-de-ju-zi/</id>
        <link href="https://zxianwei.github.io/zhen-cang-de-ju-zi/">
        </link>
        <updated>2020-03-22T06:26:14.000Z</updated>
        <summary type="html"><![CDATA[<p>人民有信仰，国家有力量，民族有希望。</p>
<p>在生命的旅途里遇见你真好!</p>
]]></summary>
        <content type="html"><![CDATA[<p>人民有信仰，国家有力量，民族有希望。</p>
<p>在生命的旅途里遇见你真好!</p>
<!-- more -->
<p>山川异域，风月同天。</p>
<p>卑鄙是卑鄙者的通行证，高尚是高尚者的墓志铭。</p>
<p>当混浊变成一种常态，清白就是一种罪。</p>
<p>爱笑的人运气不会太差，运气差的人压根笑不出来。</p>
<p>我想牵着你的手，敬各位来宾的酒！</p>
<p>闲时与你立黄昏，灶前笑问粥可温。</p>
<p>你是我患得患失的梦，我是你可有可无的人。</p>
<p>当朋友圈换了一批人给你点赞，才知道时间带走了什么。</p>
<p>我从出生就信仰着她，热爱着她。直到今天我带着失望审视着她！</p>
<p>育人，育心，育前程！</p>
<p>人来求我三春雨，我求别人六月霜。</p>
<p>我怕鬼，鬼却未伤我一分一豪，我不怕人，人却弄的我体无全服。</p>
<p>可悲的是身边最亲的人都是自己亲手埋的，可喜的是身边再也不会有人失去…</p>
<p>若是气质藏于身，岁月从不败美人。</p>
<p>难吃不过无盐面，狼吞虎咽必有难。</p>
<p>医院的墙上比教堂听到更多真挚的祷告。</p>
<p>善恶的区别，在于行为的本身，不在于地位的有无。——莎士比亚</p>
<p>你要藏好软弱，世界大雨滂沱。万物苟且而活，无人为你背负更多。</p>
<p>我们都是平凡的人类，没有高低贵贱之分。</p>
<p>白富美：洁身自好为白，经济独立为富，内外兼修为美。</p>
<p>我一直都相信，好人一定会有好报的。</p>
<p>100岁都那么乐观，20多岁的我有什么理由堕落！ 加油!</p>
<p>眼花缭乱 固守本心 方能得始终。</p>
<p>目之所及，皆是回忆，心之所想，皆是过往，眼之所看，皆是遗憾。</p>
<p>今天无意中看了一段白话，讲的太棒了，鸡叫了天会亮，鸡不叫天也会亮，天亮不亮不是鸡说了算，关键是谁醒了。醒来的过了一天，没醒的过了一生。有个人买了一箱梨，天气热怕梨坏了可惜，每天挑几个最差的吃掉，最后却吃了一箱烂梨。总结一下，作幅对联:上联:放着好的吃烂的下联:吃了烂的烂好的横批:永远吃烂的感悟:人生亦如吃梨，因为在意每天不开心的事，一辈子都得糟心下去；把糟心的事放下扔掉，每天阳光一点，你就灿烂一辈子！珍惜当下，积极快乐！没人天生就懂得控制情绪。真正有智慧的人，是时刻留意，不要让自己栽在坏情绪中！加油！</p>
<p>当我踏上火车的那一刻才意识到，从此以后，故乡的季节只有冬，再无春夏秋）从小觉得最厉害的人就是妈妈，不怕黑，什么都知道，做好吃的饭，把生活打理得井井有条，哭着不知道怎么办时只好找她。可我好像忘了这个被我依靠的人也曾是个小姑娘，怕黑也掉眼泪，笨手笨脚会被针扎到手。最美的姑娘，是什么让你变得这么强大呢，是岁月，还是爱。 ——德卡先生</p>
<p>轻财足以聚人，律己足以服人，量宽足以得人，身先足以率人。</p>
<p>因为不知道下一辈子 还能不能遇到你 所以这辈子要不顾一切地和你在一起把我最好的都给你。</p>
<p>我从未让他们骄傲，但他们始终待我如珍宝。致天下所有父母！</p>
<p>你眼中倒映的星河烂漫，是不曾见过的世外桃源。</p>
<p>穷极一生，尽其一世，钟情一人！</p>
<p>生而未养，断指可还，生而养之，断头可还，未生而养，百世难还。</p>
<p>真正爱你的人会督促你变的优秀，而不是蹉跎你的青春。</p>
<p>愿你所有的钟情，都能换来真意；愿你所有的等待，都能不被辜负；愿你所有的美好，都能如期而至。</p>
<p>他山之石可以攻玉。</p>
<p>一身清贫怎敢入繁华，两袖清风怎敢误佳人。</p>
<p>不是每一场相遇都会有结局，但是每一场相遇都会有意义。</p>
<p>纵我心如红铁 难融你三尺寒心。</p>
<p>要想台前显贵，您必得台下受罪！</p>
<p>身无饥寒 父母无愧于我 人无长进 我以何待父母。</p>
<p>我的冷漠里，一半是自卑，一半是害羞。</p>
<p>过错，最终，最初，同类，信仰，意外，眼界，失败，成功。</p>
<p>有些人，一旦分开，一辈子可能就见不到了。</p>
<p>如果皮囊难以修复，就用思想填满它。</p>
<p>由来一声笑，男儿自横行。</p>
<p>正义不是不会迟到，而是没来的那部分慢慢被人遗忘。</p>
<p>有些事情,再不去做就忘了.有些人,再不去找就没了。</p>
<p>吉时吉日吉如风丰年丰月如风筝争福争财争长寿寿山寿海寿长生生福生财生贵子子孝孙贤代代荣荣华富贵年年有有钱有势有前程。</p>
<p>这个怪物叫社会，他夺取的叫时间，给你的是经验，踩的楼梯是信任，扶的扶手是支持，提的箱子叫责任，整幅画叫人生。</p>
<p>不怕电影虚幻，就怕电影根据真实事件改编，你眼里的星河烂漫，是我从未见过的室外桃源。加油孩子，你会得到最完美的幸福！</p>
<p>中国十大名曲:《高山流水》《梅花三弄》《夕阳箫鼓》《汉宫秋月》《阳春白雪》《渔樵问答》《胡笳十八拍》《广陵散》《平沙落雁》《十面埋伏》</p>
<p>别忘了答应自己要做的事情，别忘了答应自己要去的地方，无论有多难，有多远。愿有人与你共黄昏，有人问你粥可温。经常梳理下自己，热爱生活，生活也会爱你的。</p>
<p>你所浪费的今天，是昨天死去的人所奢望的明天，你所厌恶的现在，是未来的你回不去的曾经，时间残忍，珍惜眼前人。</p>
<p>树欲静而风不止，子欲养而亲不待。</p>
<p>玲珑骰子安红豆，入骨相思知不知。</p>
<p>春赏百花冬观雪，醒亦念卿，梦亦念卿！</p>
<p>红豆生南国，春来发几枝。愿君多采撷，此物最相思。</p>
<p>我一生没做坏事，为何会这样。</p>
<p>人之初，性本善.</p>
<p>我眼里有一座天空之城，它晶莹透剔，里面有一个人，我看不清她的模样.</p>
<p>希望你们像Microsoft般健壮; 女生像macOS般漂亮; 桃花运像IE中毒般频繁; 钱包如OneDrive容量般壮大, 升职速度赶上Windows出Bug; 追女朋友像木马一样猖獗; 生活像重装电脑后一样幸福; 写程序敲代码和聊天一样有激情。<br>
最后: 愿世界再无bug。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 全面分析 Spring 的编程式事务管理及声明式事务管理 ]]></title>
        <id>https://zxianwei.github.io/zhuan-zai/</id>
        <link href="https://zxianwei.github.io/zhuan-zai/">
        </link>
        <updated>2019-07-25T13:21:15.000Z</updated>
        <summary type="html"><![CDATA[<p><a href="https://www.ibm.com/developerworks/cn/education/opensource/os-cn-spring-trans/index.html">全面分析 Spring 的编程式事务管理及声明式事务管理</a></p>
<h4 id="关于本教程">关于本教程</h4>
<p>本教程将深入讲解 Spring 简单而强大的事务管理功能，包括编程式事务和声明式事务。通过对本教程的学习，您将能够理解 Spring 事务管理的本质，并灵活运用之。</p>
]]></summary>
        <content type="html"><![CDATA[<p><a href="https://www.ibm.com/developerworks/cn/education/opensource/os-cn-spring-trans/index.html">全面分析 Spring 的编程式事务管理及声明式事务管理</a></p>
<h4 id="关于本教程">关于本教程</h4>
<p>本教程将深入讲解 Spring 简单而强大的事务管理功能，包括编程式事务和声明式事务。通过对本教程的学习，您将能够理解 Spring 事务管理的本质，并灵活运用之。</p>
<!-- more -->
<h4 id="先决条件">先决条件</h4>
<p>本教程假定您已经掌握了 Java 基础知识，并对 Spring 有一定了解。您还需要具备基本的事务管理的知识，比如：事务的定义，隔离级别的概念，等等。本文将直接使用这些概念而不做详细解释。另外，您最好掌握数据库的基础知识，虽然这不是必须。</p>
<h4 id="系统需求">系统需求</h4>
<p>要试验这份教程中的工具和示例，硬件配置需求为：至少带有 512MB 内存（推荐 1GB）的系统。需要安装以下软件：</p>
<!--more-->
<ul>
<li>Sun JDK 5.0 或更新版本或 IBM Developer Kit for the Java 5 platform 版本。</li>
<li>Spring framework 2.5。本教程附带的示例代码已经在 Spring 2.5.6 上测试过。</li>
<li>MySQL 5.0 或更新版本。</li>
</ul>
<h4 id="spring-事务属性分析">Spring 事务属性分析</h4>
<p>事务管理对于企业应用而言至关重要。它保证了用户的每一次操作都是可靠的，即便出现了异常的访问情况，也不至于破坏后台数据的完整性。就像银行的自助取款机，通常都能正常为客户服务，但是也难免遇到操作过程中机器突然出故障的情况，此时，事务就必须确保出故障前对账户的操作不生效，就像用户刚才完全没有使用过取款机一样，以保证用户和银行的利益都不受损失。</p>
<p>在 Spring 中，事务是通过 TransactionDefinition 接口来定义的。该接口包含与事务属性有关的方法。具体如清单1所示：</p>
<p>清单1. TransactionDefinition 接口中定义的主要方法</p>
<pre><code>public interface TransactionDefinition{
int getIsolationLevel();
int getPropagationBehavior();
int getTimeout();
boolean isReadOnly();
}
</code></pre>
<p>也许你会奇怪，为什么接口只提供了获取属性的方法，而没有提供相关设置属性的方法。其实道理很简单，事务属性的设置完全是程序员控制的，因此程序员可以自定义任何设置属性的方法，而且保存属性的字段也没有任何要求。唯一的要求的是，Spring 进行事务操作的时候，通过调用以上接口提供的方法必须能够返回事务相关的属性取值。</p>
<h4 id="事务隔离级别">事务隔离级别</h4>
<p>隔离级别是指若干个并发的事务之间的隔离程度。TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p>
<ul>
<li>TransactionDefinition.ISOLATION_DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是TransactionDefinition.ISOLATION_READ_COMMITTED。</li>
<li>TransactionDefinition.ISOLATION_READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读和不可重复读，因此很少使用该隔离级别。</li>
<li>TransactionDefinition.ISOLATION_READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。</li>
<li>TransactionDefinition.ISOLATION_REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。该级别可以防止脏读和不可重复读。</li>
<li>TransactionDefinition.ISOLATION_SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h4 id="事务传播行为">事务传播行为</h4>
<p>所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。在TransactionDefinition定义中包括了如下几个表示传播行为的常量：</p>
<ul>
<li>TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
<li>TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li>
<li>TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li>
<li>TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。<br>
这里需要指出的是，前面的六种事务传播行为是 Spring 从 EJB 中引入的，他们共享相同的概念。而 PROPAGATION_NESTED是 Spring 所特有的。以 PROPAGATION_NESTED 启动的事务内嵌于外部事务中（如果存在外部事务的话），此时，内嵌事务并不是一个独立的事务，它依赖于外部事务的存在，只有通过外部的事务提交，才能引起内部事务的提交，嵌套的子事务不能单独提交。如果熟悉 JDBC 中的保存点（SavePoint）的概念，那嵌套事务就很容易理解了，其实嵌套的子事务就是保存点的一个应用，一个事务中可以包括多个保存点，每一个嵌套子事务。另外，外部事务的回滚也会导致嵌套子事务的回滚。</li>
</ul>
<h4 id="事务超时">事务超时</h4>
<p>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。</p>
<h4 id="事务的只读属性">事务的只读属性</h4>
<p>事务的只读属性是指，对事务性资源进行只读操作或者是读写操作。所谓事务性资源就是指那些被事务管理的资源，比如数据源、 JMS 资源，以及自定义的事务性资源等等。如果确定只对事务性资源进行只读操作，那么我们可以将事务标志为只读的，以提高事务处理的性能。在 TransactionDefinition 中以 boolean 类型来表示该事务是否只读。</p>
<h4 id="事务的回滚规则">事务的回滚规则</h4>
<p>通常情况下，如果在事务中抛出了未检查异常（继承自 RuntimeException 的异常），则默认将回滚事务。如果没有抛出任何异常，或者抛出了已检查异常，则仍然提交事务。这通常也是大多数开发者希望的处理方式，也是 EJB 中的默认处理方式。但是，我们可以根据需要人为控制事务在抛出某些未检查异常时任然提交事务，或者在抛出某些已检查异常时回滚事务。</p>
<h4 id="spring-事务管理-api-分析">Spring 事务管理 API 分析</h4>
<p>Spring 框架中，涉及到事务管理的 API 大约有100个左右，其中最重要的有三个：TransactionDefinition、PlatformTransactionManager、TransactionStatus。所谓事务管理，其实就是“按照给定的事务规则来执行提交或者回滚操作”。“给定的事务规则”就是用 TransactionDefinition 表示的，“按照……来执行提交或者回滚操作”便是用 PlatformTransactionManager 来表示，而 TransactionStatus 用于表示一个运行着的事务的状态。打一个不恰当的比喻，TransactionDefinition 与 TransactionStatus 的关系就像程序和进程的关系。</p>
<h4 id="transactiondef">TransactionDef...</h4>
<p>该接口在前面已经介绍过，它用于定义一个事务。它包含了事务的静态属性，比如：事务传播行为、超时时间等等。Spring 为我们提供了一个默认的实现类：DefaultTransactionDefinition，该类适用于大多数情况。如果该类不能满足需求，可以通过实现 TransactionDefinition 接口来实现自己的事务定义。</p>
<p>PlatformTrans...<br>
PlatformTransactionManager 用于执行具体的事务操作。接口定义如清单2所示：</p>
<p>清单2. PlatformTransactionManager 接口中定义的主要方法</p>
<pre><code>Public interface PlatformTransactionManager{
  TransactionStatus getTransaction(TransactionDefinition definition)
   throws TransactionException;
   void commit(TransactionStatus status)throws TransactionException;
   void rollback(TransactionStatus status)throws TransactionException;
}
</code></pre>
<p>根据底层所使用的不同的持久化 API 或框架，PlatformTransactionManager 的主要实现类大致如下：</p>
<ul>
<li>DataSourceTransactionManager：适用于使用JDBC和iBatis进行数据持久化操作的情况。</li>
<li>HibernateTransactionManager：适用于使用Hibernate进行数据持久化操作的情况。</li>
<li>JpaTransactionManager：适用于使用JPA进行数据持久化操作的情况。</li>
<li>另外还有JtaTransactionManager 、JdoTransactionManager、JmsTransactionManager等等。<br>
如果我们使用JTA进行事务管理，我们可以通过 JNDI 和 Spring 的 JtaTransactionManager 来获取一个容器管理的 DataSource。JtaTransactionManager 不需要知道 DataSource 和其他特定的资源，因为它将使用容器提供的全局事务管理。而对于其他事务管理器，比如DataSourceTransactionManager，在定义时需要提供底层的数据源作为其属性，也就是 DataSource。与 HibernateTransactionManager 对应的是 SessionFactory，与 JpaTransactionManager 对应的是 EntityManagerFactory 等等。</li>
</ul>
<h4 id="transactionstatus">TransactionStatus</h4>
<p>PlatformTransactionManager.getTransaction(…) 方法返回一个 TransactionStatus 对象。返回的TransactionStatus 对象可能代表一个新的或已经存在的事务（如果在当前调用堆栈有一个符合条件的事务）。TransactionStatus 接口提供了一个简单的控制事务执行和查询事务状态的方法。该接口定义如清单3所示：</p>
<p>清单3. TransactionStatus 接口中定义的主要方法</p>
<pre><code>public  interface TransactionStatus{
   boolean isNewTransaction();
   void setRollbackOnly();
   boolean isRollbackOnly();
}
</code></pre>
<h3 id="编程式事务管理">编程式事务管理</h3>
<h4 id="spring-的编程式事务管理概述">Spring 的编程式事务管理概述</h4>
<p>在 Spring 出现以前，编程式事务管理对基于 POJO 的应用来说是唯一选择。用过 Hibernate 的人都知道，我们需要在代码中显式调用beginTransaction()、commit()、rollback()等事务管理相关的方法，这就是编程式事务管理。通过 Spring 提供的事务管理 API，我们可以在代码中灵活控制事务的执行。在底层，Spring 仍然将事务操作委托给底层的持久化框架来执行。</p>
<h4 id="基于底层-api-的编程式事务管理">基于底层 API 的编程式事务管理</h4>
<p>根据PlatformTransactionManager、TransactionDefinition 和 TransactionStatus 三个核心接口，我们完全可以通过编程的方式来进行事务管理。示例代码如清单4所示：</p>
<p>清单4. 基于底层 API 的事务管理示例代码</p>
<pre><code>public class BankServiceImpl implements BankService {
private BankDao bankDao;
private TransactionDefinition txDefinition;
private PlatformTransactionManager txManager;
......
public boolean transfer(Long fromId， Long toId， double amount) {
TransactionStatus txStatus = txManager.getTransaction(txDefinition);
boolean result = false;
try {
result = bankDao.transfer(fromId， toId， amount);
txManager.commit(txStatus);
} catch (Exception e) {
result = false;
txManager.rollback(txStatus);
System.out.println(&quot;Transfer Error!&quot;);
}
return result;
}
}
</code></pre>
<p>相应的配置文件如清单5所示：</p>
<p>清单5. 基于底层API的事务管理示例配置文件</p>
<pre><code>&lt;bean id=&quot;bankService&quot; class=&quot;footmark.spring.core.tx.programmatic.origin.BankServiceImpl&quot;&gt;
&lt;property name=&quot;bankDao&quot; ref=&quot;bankDao&quot;/&gt;
&lt;property name=&quot;txManager&quot; ref=&quot;transactionManager&quot;/&gt;
&lt;property name=&quot;txDefinition&quot;&gt;
&lt;bean class=&quot;org.springframework.transaction.support.DefaultTransactionDefinition&quot;&gt;
&lt;property name=&quot;propagationBehaviorName&quot; value=&quot;PROPAGATION_REQUIRED&quot;/&gt;
&lt;/bean&gt;
&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>如上所示，我们在类中增加了两个属性：一个是 TransactionDefinition 类型的属性，它用于定义一个事务；另一个是 PlatformTransactionManager 类型的属性，用于执行事务管理操作。</p>
<p>如果方法需要实施事务管理，我们首先需要在方法开始执行前启动一个事务，调用PlatformTransactionManager.getTransaction(...) 方法便可启动一个事务。创建并启动了事务之后，便可以开始编写业务逻辑代码，然后在适当的地方执行事务的提交或者回滚。</p>
<h4 id="基于-transactiontemplate-的编程式事务管理">基于 TransactionTemplate 的编程式事务管理</h4>
<p>通过前面的示例可以发现，这种事务管理方式很容易理解，但令人头疼的是，事务管理的代码散落在业务逻辑代码中，破坏了原有代码的条理性，并且每一个业务方法都包含了类似的启动事务、提交/回滚事务的样板代码。幸好，Spring 也意识到了这些，并提供了简化的方法，这就是 Spring 在数据访问层非常常见的模板回调模式。如清单6所示：</p>
<p>清单6. 基于 TransactionTemplate 的事务管理示例代码</p>
<pre><code>
public class BankServiceImpl implements BankService {
private BankDao bankDao;
private TransactionTemplate transactionTemplate;
......
public boolean transfer(final Long fromId， final Long toId， final double amount) {
return (Boolean) transactionTemplate.execute(new TransactionCallback(){
public Object doInTransaction(TransactionStatus status) {
Object result;
try {
result = bankDao.transfer(fromId， toId， amount);
} catch (Exception e) {
status.setRollbackOnly();
result = false;
System.out.println(&quot;Transfer Error!&quot;);
}
return result;
}
});
}
}
</code></pre>
<h5 id="相应的xml配置如下">相应的XML配置如下：</h5>
<p>清单 7. 基于 TransactionTemplate 的事务管理示例配置文件</p>
<pre><code>&lt;bean id=&quot;bankService&quot;
class=&quot;footmark.spring.core.tx.programmatic.template.BankServiceImpl&quot;&gt;
&lt;property name=&quot;bankDao&quot; ref=&quot;bankDao&quot;/&gt;
&lt;property name=&quot;transactionTemplate&quot; ref=&quot;transactionTemplate&quot;/&gt;
&lt;/bean&gt;

</code></pre>
<p>TransactionTemplate 的 execute() 方法有一个 TransactionCallback 类型的参数，该接口中定义了一个 doInTransaction() 方法，通常我们以匿名内部类的方式实现 TransactionCallback 接口，并在其 doInTransaction() 方法中书写业务逻辑代码。这里可以使用默认的事务提交和回滚规则，这样在业务代码中就不需要显式调用任何事务管理的 API。doInTransaction() 方法有一个TransactionStatus 类型的参数，我们可以在方法的任何位置调用该参数的 setRollbackOnly() 方法将事务标识为回滚的，以执行事务回滚。</p>
<p>根据默认规则，如果在执行回调方法的过程中抛出了未检查异常，或者显式调用了TransacationStatus.setRollbackOnly() 方法，则回滚事务；如果事务执行完成或者抛出了 checked 类型的异常，则提交事务。</p>
<p>TransactionCallback 接口有一个子接口 TransactionCallbackWithoutResult，该接口中定义了一个 doInTransactionWithoutResult() 方法，TransactionCallbackWithoutResult 接口主要用于事务过程中不需要返回值的情况。当然，对于不需要返回值的情况，我们仍然可以使用 TransactionCallback 接口，并在方法中返回任意值即可。</p>
<h3 id="声明式事务管理">声明式事务管理</h3>
<h4 id="spring-的声明式事务管理概述">Spring 的声明式事务管理概述</h4>
<p>Spring 的声明式事务管理在底层是建立在 AOP 的基础之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p>
<p>声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明（或通过等价的基于标注的方式），便可以将事务规则应用到业务逻辑中。因为事务管理本身就是一个典型的横切逻辑，正是 AOP 的用武之地。Spring 开发团队也意识到了这一点，为声明式事务提供了简单而强大的支持。</p>
<p>声明式事务管理曾经是 EJB 引以为傲的一个亮点，如今 Spring 让 POJO 在事务管理方面也拥有了和 EJB 一样的待遇，让开发人员在 EJB 容器之外也用上了强大的声明式事务管理功能，这主要得益于 Spring 依赖注入容器和 Spring AOP 的支持。依赖注入容器为声明式事务管理提供了基础设施，使得 Bean 对于 Spring 框架而言是可管理的；而 Spring AOP 则是声明式事务管理的直接实现者，这一点通过清单8可以看出来。</p>
<p>通常情况下，笔者强烈建议在开发中使用声明式事务，不仅因为其简单，更主要是因为这样使得纯业务代码不被污染，极大方便后期的代码维护。</p>
<p>和编程式事务相比，声明式事务唯一不足地方是，后者的最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。但是即便有这样的需求，也存在很多变通的方法，比如，可以将需要进行事务管理的代码块独立为方法等等。</p>
<p>下面就来看看 Spring 为我们提供的声明式事务管理功能。</p>
<h4 id="基于-transactioninter-的声明式事务管理">基于 TransactionInter... 的声明式事务管理</h4>
<p>最初，Spring 提供了 TransactionInterceptor 类来实施声明式事务管理功能。先看清单8的配置文件：</p>
<p>清单 8. 基于 TransactionInterceptor 的事务管理示例配置文件</p>
<pre><code>&lt;beans...&gt;
......
&lt;bean id=&quot;transactionInterceptor&quot;
class=&quot;org.springframework.transaction.interceptor.TransactionInterceptor&quot;&gt;
&lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt;
&lt;property name=&quot;transactionAttributes&quot;&gt;
&lt;props&gt;
&lt;prop key=&quot;transfer&quot;&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
&lt;/props&gt;
&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=&quot;bankServiceTarget&quot;
class=&quot;footmark.spring.core.tx.declare.origin.BankServiceImpl&quot;&gt;
&lt;property name=&quot;bankDao&quot; ref=&quot;bankDao&quot;/&gt;
&lt;/bean&gt;
&lt;bean id=&quot;bankService&quot;
class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;
&lt;property name=&quot;target&quot; ref=&quot;bankServiceTarget&quot;/&gt;
&lt;property name=&quot;interceptorNames&quot;&gt;
&lt;list&gt;
&lt;idref bean=&quot;transactionInterceptor&quot;/&gt;
&lt;/list&gt;
&lt;/property&gt;
&lt;/bean&gt;
......
&lt;/beans&gt;
</code></pre>
<p>首先，我们配置了一个 TransactionInterceptor 来定义相关的事务规则，他有两个主要的属性：一个是 transactionManager，用来指定一个事务管理器，并将具体事务相关的操作委托给它；另一个是 Properties 类型的 transactionAttributes 属性，它主要用来定义事务规则，该属性的每一个键值对中，键指定的是方法名，方法名可以使用通配符，而值就表示相应方法的所应用的事务属性。</p>
<p>指定事务属性的取值有较复杂的规则，这在 Spring 中算得上是一件让人头疼的事。具体的书写规则如下：</p>
<p>1传播行为 [，隔离级别] [，只读属性] [，超时属性] [不影响提交的异常] [，导致回滚的异常]</p>
<ul>
<li>传播行为是唯一必须设置的属性，其他都可以忽略，Spring为我们提供了合理的默认值。</li>
<li>传播行为的取值必须以“PROPAGATION_”开头，具体包括：PROPAGATION_MANDATORY、PROPAGATION_NESTED、PROPAGATION_NEVER、PROPAGATION_NOT_SUPPORTED、PROPAGATION_REQUIRED、PROPAGATION_REQUIRES_NEW、PROPAGATION_SUPPORTS，共七种取值。</li>
<li>隔离级别的取值必须以“ISOLATION_”开头，具体包括：ISOLATION_DEFAULT、ISOLATION_READ_COMMITTED、ISOLATION_READ_UNCOMMITTED、ISOLATION_REPEATABLE_READ、ISOLATION_SERIALIZABLE，共五种取值。</li>
<li>如果事务是只读的，那么我们可以指定只读属性，使用“readOnly”指定。否则我们不需要设置该属性。</li>
<li>超时属性的取值必须以“TIMEOUT_”开头，后面跟一个int类型的值，表示超时时间，单位是秒。</li>
<li>不影响提交的异常是指，即使事务中抛出了这些类型的异常，事务任然正常提交。必须在每一个异常的名字前面加上“+”。异常的名字可以是类名的一部分。比如“+RuntimeException”、“+tion”等等。</li>
<li>导致回滚的异常是指，当事务中抛出这些类型的异常时，事务将回滚。必须在每一个异常的名字前面加上“-”。异常的名字可以是类名的全部或者部分，比如“-RuntimeException”、“-tion”等等。<br>
以下是两个示例：</li>
</ul>
<pre><code>&lt;property name=&quot;*Service&quot;&gt;
PROPAGATION_REQUIRED，ISOLATION_READ_COMMITTED，TIMEOUT_20，
+AbcException，+DefException，-HijException
&lt;/property&gt;
</code></pre>
<p>以上表达式表示，针对所有方法名以 Service 结尾的方法，使用 PROPAGATION_REQUIRED 事务传播行为，事务的隔离级别是 ISOLATION_READ_COMMITTED，超时时间为20秒，当事务抛出 AbcException 或者 DefException 类型的异常，则仍然提交，当抛出 HijException 类型的异常时必须回滚事务。这里没有指定&quot;readOnly&quot;，表示事务不是只读的。</p>
<p>1<br>
<property name="test">PROPAGATION_REQUIRED，readOnly</property><br>
以上表达式表示，针对所有方法名为 test 的方法，使用 PROPAGATION_REQUIRED 事务传播行为，并且该事务是只读的。除此之外，其他的属性均使用默认值。比如，隔离级别和超时时间使用底层事务性资源的默认值，并且当发生未检查异常，则回滚事务，发生已检查异常则仍提交事务。</p>
<p>配置好了 TransactionInterceptor，我们还需要配置一个 ProxyFactoryBean 来组装 target 和advice。这也是典型的 Spring AOP 的做法。通过 ProxyFactoryBean 生成的代理类就是织入了事务管理逻辑后的目标类。至此，声明式事务管理就算是实现了。我们没有对业务代码进行任何操作，所有设置均在配置文件中完成，这就是声明式事务的最大优点。</p>
<h4 id="基于-transactionproxy-的声明式事务管理">基于 TransactionProxy... 的声明式事务管理</h4>
<p>前面的声明式事务虽然好，但是却存在一个非常恼人的问题：配置文件太多。我们必须针对每一个目标对象配置一个 ProxyFactoryBean；另外，虽然可以通过父子 Bean 的方式来复用 TransactionInterceptor 的配置，但是实际的复用几率也不高；这样，加上目标对象本身，每一个业务类可能需要对应三个 <bean/> 配置，随着业务类的增多，配置文件将会变得越来越庞大，管理配置文件又成了问题。</p>
<p>为了缓解这个问题，Spring 为我们提供了 TransactionProxyFactoryBean，用于将TransactionInterceptor 和 ProxyFactoryBean 的配置合二为一。如清单9所示：</p>
<p>清单9. 基于 TransactionProxyFactoryBean 的事务管理示例配置文件</p>
<pre><code>&lt;beans......&gt;
......
&lt;bean id=&quot;bankServiceTarget&quot;
class=&quot;footmark.spring.core.tx.declare.classic.BankServiceImpl&quot;&gt;
&lt;property name=&quot;bankDao&quot; ref=&quot;bankDao&quot;/&gt;
&lt;/bean&gt;
&lt;bean id=&quot;bankService&quot;
class=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;&gt;
&lt;property name=&quot;target&quot; ref=&quot;bankServiceTarget&quot;/&gt;
&lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt;
&lt;property name=&quot;transactionAttributes&quot;&gt;
&lt;props&gt;
&lt;prop key=&quot;transfer&quot;&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
&lt;/props&gt;
&lt;/property&gt;
&lt;/bean&gt;
......
&lt;/beans&gt;
</code></pre>
<p>如此一来，配置文件与先前相比简化了很多。我们把这种配置方式称为 Spring 经典的声明式事务管理。相信在早期使用 Spring 的开发人员对这种配置声明式事务的方式一定非常熟悉。</p>
<p>但是，显式为每一个业务类配置一个 TransactionProxyFactoryBean 的做法将使得代码显得过于刻板，为此我们可以使用自动创建代理的方式来将其简化，使用自动创建代理是纯 AOP 知识，请读者参考相关文档，不在此赘述。</p>
<h4 id="基于-tx-命名空间的声明式事务管理">基于 <tx> 命名空间的声明式事务管理</h4>
<p>前面两种声明式事务配置方式奠定了 Spring 声明式事务管理的基石。在此基础上，Spring 2.x 引入了 <tx> 命名空间，结合使用 <aop> 命名空间，带给开发人员配置声明式事务的全新体验，配置变得更加简单和灵活。另外，得益于 <aop> 命名空间的切点表达式支持，声明式事务也变得更加强大。</p>
<p>如清单10所示：</p>
<p>清单10. 基于 <tx> 的事务管理示例配置文件</p>
<pre><code>&lt;beans......&gt;
......
&lt;bean id=&quot;bankService&quot;
class=&quot;footmark.spring.core.tx.declare.namespace.BankServiceImpl&quot;&gt;
&lt;property name=&quot;bankDao&quot; ref=&quot;bankDao&quot;/&gt;
&lt;/bean&gt;
&lt;tx:advice id=&quot;bankAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
&lt;tx:attributes&gt;
&lt;tx:method name=&quot;transfer&quot; propagation=&quot;REQUIRED&quot;/&gt;
&lt;/tx:attributes&gt;
&lt;/tx:advice&gt;
 
&lt;aop:config&gt;
&lt;aop:pointcut id=&quot;bankPointcut&quot; expression=&quot;execution(* *.transfer(..))&quot;/&gt;
&lt;aop:advisor advice-ref=&quot;bankAdvice&quot; pointcut-ref=&quot;bankPointcut&quot;/&gt;
&lt;/aop:config&gt;
......
&lt;/beans&gt;

</code></pre>
<p>如果默认的事务属性就能满足要求，那么代码简化为如清单 11 所示：</p>
<p>清单 11. 简化后的基于 <tx> 的事务管理示例配置文件</p>
<pre><code>&lt;beans......&gt;
......
&lt;bean id=&quot;bankService&quot;
class=&quot;footmark.spring.core.tx.declare.namespace.BankServiceImpl&quot;&gt;
&lt;property name=&quot;bankDao&quot; ref=&quot;bankDao&quot;/&gt;
&lt;/bean&gt;
&lt;tx:advice id=&quot;bankAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
&lt;aop:config&gt;
&lt;aop:pointcut id=&quot;bankPointcut&quot; expression=&quot;execution(**.transfer(..))&quot;/&gt;
&lt;aop:advisor advice-ref=&quot;bankAdvice&quot; pointcut-ref=&quot;bankPointcut&quot;/&gt;
&lt;/aop:config&gt;
......
&lt;/beans&gt;
</code></pre>
<p>由于使用了切点表达式，我们就不需要针对每一个业务类创建一个代理对象了。另外，如果配置的事务管理器 Bean 的名字取值为“transactionManager”，则我们可以省略 <a href="tx:advice">tx:advice</a> 的 transaction-manager 属性，因为该属性的默认值即为“transactionManager”。</p>
<h4 id="基于-transactional-的声明式事务管理">基于 @Transactional 的声明式事务管理</h4>
<p>除了基于命名空间的事务配置方式，Spring 2.x 还引入了基于 Annotation 的方式，具体主要涉及@Transactional 标注。@Transactional 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如清单12所示：</p>
<p>清单12. 基于 @Transactional 的事务管理示例配置文件</p>
<pre><code>@Transactional(propagation = Propagation.REQUIRED)
public boolean transfer(Long fromId， Long toId， double amount) {
return bankDao.transfer(fromId， toId， amount);
}
</code></pre>
<p>Spring 使用 BeanPostProcessor 来处理 Bean 中的标注，因此我们需要在配置文件中作如下声明来激活该后处理 Bean，如清单13所示：</p>
<p>清单13. 启用后处理Bean的配置</p>
<pre><code>&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;
</code></pre>
<p>与前面相似，transaction-manager 属性的默认值是 transactionManager，如果事务管理器 Bean 的名字即为该值，则可以省略该属性。</p>
<p>虽然 @Transactional 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 小组建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， @Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的。如果你在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常。</p>
<p>基于 <tx> 命名空间和基于 @Transactional 的事务声明方式各有优缺点。基于 <tx> 的方式，其优点是与切点表达式结合，功能强大。利用切点表达式，一个配置可以匹配多个方法，而基于 @Transactional 的方式必须在每一个需要使用事务的方法或者类上用 @Transactional 标注，尽管可能大多数事务的规则是一致的，但是对 @Transactional 而言，也无法重用，必须逐个指定。另一方面，基于 @Transactional 的方式使用起来非常简单明了，没有学习成本。开发人员可以根据需要，任选其中一种使用，甚至也可以根据需要混合使用这两种方式。</p>
<p>如果不是对遗留代码进行维护，则不建议再使用基于 TransactionInterceptor 以及基于TransactionProxyFactoryBean 的声明式事务管理方式，但是，学习这两种方式非常有利于对底层实现的理解。</p>
<p>虽然上面共列举了四种声明式虽然上面共列举了四种声明式事务管理方式，但是这样的划分只是为了便于理解，其实后台的实现方式是一样的，只是</p>
<h3 id="结束语">结束语</h3>
<p>本教程的知识点大致总结如下：</p>
<ul>
<li>基于onDefinition、PlatformTransactionManager、TransactionStatus 编程式事务管理是 Spring 提供的最原始的方式，通常我们不会这么写，但是了解这种方式对理解 Spring 事务管理的本质有很大作用。</li>
<li>基于 TransactionTemplate 的编程式事务管理是对上一种方式的封装，使得编码更简单、清晰。</li>
<li>基于 TransactionInterceptor 的声明式事务是 Spring 声明式事务的基础，通常也不建议使用这种方式，但是与前面一样，了解这种方式对理解 Spring 声明式事务有很大作用。</li>
<li>基于 TransactionProxyFactoryBean 的声明式事务是上中方式的改进版本，简化的配置文件的书写，这是 Spring 早期推荐的声明式事务管理方式，但是在 Spring 2.0 中已经不推荐了。</li>
<li>基于 <tx> 和 <aop> 命名空间的声明式事务管理是目前推荐的方式，其最大特点是与 Spring AOP 结合紧密，可以充分利用切点表达式的强大支持，使得管理事务更加灵活。</li>
<li>基于 @Transactional 的方式将声明式事务管理简化到了极致。开发人员只需在配置文件中加上一行启用相关后处理 Bean 的配置，然后在需要实施事务管理的方法或者类上使用 @Transactional 指定事务规则即可实现事务管理，而且功能也不必其他方式逊色。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring中使用JDBC Template访问数据库]]></title>
        <id>https://zxianwei.github.io/spring-zhong-shi-yong-jdbc-template-fang-wen-shu-ju-ku/</id>
        <link href="https://zxianwei.github.io/spring-zhong-shi-yong-jdbc-template-fang-wen-shu-ju-ku/">
        </link>
        <updated>2019-07-17T12:58:51.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="简介">简介</h4>
<ul>
<li>为了简化持久化操作，Spring在JDBC API之上提供了JDBC Template组件。</li>
<li>JDBC Template提供统一的模板方法，在保留代码灵活性的基础上，尽量减少持久化代码。</li>
</ul>
<h4 id="创建项目">创建项目</h4>
]]></summary>
        <content type="html"><![CDATA[<h4 id="简介">简介</h4>
<ul>
<li>为了简化持久化操作，Spring在JDBC API之上提供了JDBC Template组件。</li>
<li>JDBC Template提供统一的模板方法，在保留代码灵活性的基础上，尽量减少持久化代码。</li>
</ul>
<h4 id="创建项目">创建项目</h4>
<!--more-->
<p>创建maven项目，完整的项目结构是这样的<br>
<img src="https://upload-images.jianshu.io/upload_images/4148711-43a1ef4995206058.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" loading="lazy"><br>
在pom文件中添加项目所需要的依赖</p>
<pre><code>    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;
            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;
            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
          &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.6&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<p>在applicationContext.xml文件中添加以下配置：</p>
<pre><code class="language-&lt;?xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;bean id=&quot;basicDataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/db1?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;zxw12345&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;basicDataSource&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ul>
<li>创建数据库</li>
</ul>
<pre><code>    private JdbcTemplate jdbcTemplate;
    private ApplicationContext applicationContext;

    {
        applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        jdbcTemplate = (JdbcTemplate) applicationContext.getBean(&quot;jdbcTemplate&quot;);
    }

    /**
     * 创建数据库
     */
    @Test
    public void execute() {
        String sql = &quot;CREATE TABLE teacher(id SMALLINT AUTO_INCREMENT PRIMARY KEY ,name VARCHAR (20),sex VARCHAR (20))&quot;;
        jdbcTemplate.execute(sql);
    }
</code></pre>
<p>可以打开终端验证有没有创建成功<br>
<img src="https://upload-images.jianshu.io/upload_images/4148711-f813610dfb72c548.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" loading="lazy"></p>
<h4 id="增删改">增删改</h4>
<ul>
<li>update:对数据进行增删改操作</li>
<li>batchUpdate:批量增删改操作</li>
</ul>
<p>添加数据</p>
<pre><code>    /**
     * 添加数据  一条数据
     */
    @Test
    public void testUpdte() {
        String sql = &quot;INSERT INTO teacher(name,sex) VALUES (?,?)&quot;;
        jdbcTemplate.update(sql, new Object[]{&quot;大小桥未久&quot;, &quot;女&quot;});
    }

    /**
     * 添加数据 数组方式
     */
    @Test
    public void batchUpdate() {
        String[] sql = {
                &quot;INSERT INTO teacher (name,sex) VALUES ('武藤兰姐姐','女')&quot;,
                &quot;INSERT INTO teacher (name,sex) VALUES ('苍井空妹妹','女')&quot;,
        };
        jdbcTemplate.batchUpdate(sql);
    }

    /**
     * 添加数据 集合方式
     */
    @Test
    public void batchUpdateArrayList() {
        String sql = &quot;INSERT INTO teacher(name,sex) VALUES (?,?)&quot;;
        List&lt;Object[]&gt; list = new ArrayList&lt;&gt;();
        list.add(new Object[]{&quot;波少野结衣&quot;, &quot;女&quot;});
        list.add(new Object[]{&quot;菜虚鲲&quot;, &quot;不祥&quot;});
        jdbcTemplate.batchUpdate(sql, list);
    }
</code></pre>
<p><s>打开终端查看一下有没有添加成功</s>可以使用查询方法进项验证</p>
<h4 id="查询">查询</h4>
<ul>
<li>queryForObject简单查询获取一个</li>
<li>queryForList简单查询获取多个</li>
<li>queryForMap查询复杂对象(封装为Map)，查询一个</li>
<li>queryForList查询复杂对象(封装为Map)，查询多个</li>
</ul>
<pre><code>    /**
     * 简单查询
     */
    @Test
    public void queryListMap() {
        String sql = &quot;SELECT * FROM teacher&quot;;
        List&lt;Map&lt;String, Object&gt;&gt; stringObjectMap = jdbcTemplate.queryForList(sql);
        System.out.println(stringObjectMap);
    }
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/4148711-1bfd3e6e51dd19e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ZLw4FP.png" loading="lazy"></figure>
<p>修改数据</p>
<pre><code>    /**
     * 修改内容
     */
    @Test
    public void updateName() {
        String sql = &quot;UPDATE teacher SET sex = ? WHERE name = ?&quot;;
        jdbcTemplate.update(sql, &quot;男女&quot;, &quot;菜虚鲲&quot;);
    }

</code></pre>
<p>删除数据</p>
<pre><code>    /**
     * 修改内容
     */
    @Test
    public void updateDelete() {
        String sql = &quot;DELETE FROM teacher WHERE name  = ? &quot;;
        jdbcTemplate.update(sql, &quot;菜虚鲲&quot;);
    }
</code></pre>
<p>查询简单数据</p>
<pre><code>    /**
     * 简单查询 查询数据长度
     */
    @Test
    public void querySize() {
        String sql = &quot;SELECT COUNT (*) FROM teacher&quot;;
        int strings = jdbcTemplate.queryForObject(sql, Integer.class);
        System.out.println(strings);
    }

    /**
     * 简单查询 根据性别查询
     */
    @Test
    public void queryList() {
        String sql = &quot;SELECT name FROM teacher WHERE sex=?&quot;;
        List&lt;String&gt; strings = jdbcTemplate.queryForList(sql, String.class, &quot;女&quot;);
        System.out.println(strings);
    }

    /**
     * 简单查询
     */
    @Test
    public void queryListMap() {
        String sql = &quot;SELECT * FROM teacher&quot;;
        List&lt;Map&lt;String, Object&gt;&gt; stringObjectMap = jdbcTemplate.queryForList(sql);
        System.out.println(stringObjectMap);
    }

    /**
     * 简单查询 map接收 长度为1
     */
    @Test
    public void queryMap() {
        String sql = &quot;SELECT * FEOM teacher WHERE id = ? &quot;;
        Map&lt;String, Object&gt; stringObjectMap = jdbcTemplate.queryForMap(sql, &quot;1&quot;);
        System.out.println(stringObjectMap);
    }

</code></pre>
<p>查询复杂数据</p>
<pre><code>package com.zxw.spring.entity;
//新建实体类
public class Student {
    private String id;
    private String name;
    private String sex;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    @Override
    public String toString() {
        return &quot;Student{&quot; +
                &quot;id='&quot; + id + '\'' +
                &quot;, name='&quot; + name + '\'' +
                &quot;, sex='&quot; + sex + '\'' +
                '}';
    }
}


       /**
     * 创建RowMapper
     */
    private class StudentRowMapper implements RowMapper&lt;Student&gt; {

        @Override
        public Student mapRow(ResultSet resultSet, int i) throws SQLException {
            Student student = new Student();
            student.setId(resultSet.getString(&quot;id&quot;));
            student.setName(resultSet.getString(&quot;name&quot;));
            student.setSex(resultSet.getString(&quot;sex&quot;));
            return student;
        }
    }



    /**
     * 查询复杂对象  获取一个
     */
    @Test
    public void queryRowMapper() {
        String sql = &quot;SELECT * FROM student WHERE id = ?&quot;;
        Student student = jdbcTemplate.queryForObject(sql, new StudentRowMapper(), &quot;10&quot;);
        System.out.println(student);
    }

    /**
     * 查询复杂对象 获取多个
     */
    @Test
    public void queryRowMapperAll() {
        String sql = &quot;SELECT * FROM STUDENT&quot;;
        List&lt;Student&gt; query = jdbcTemplate.query(sql, new StudentRowMapper());
        System.out.println(query);
    }

</code></pre>
<p>以上就是Jdbc Template的增删改查。</p>
]]></content>
    </entry>
</feed>